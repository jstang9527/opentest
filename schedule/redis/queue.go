package redis

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"time"

	"github.com/jstang9527/gateway/thirdpart/msploit"

	"github.com/jstang9527/gateway/schedule/mysql"
	"github.com/jstang9527/gateway/thirdpart/nmap"

	"github.com/garyburd/redigo/redis"
)

// InitQueue ...
func InitQueue() (err error) {
	r, err := newRedisPool("", "")
	if err != nil {
		return
	}
	go r.run()
	return
}

var (
	ch = make(chan *mysql.SecTaskInfo, 10)
	// Done ...
	Done = make(chan bool, 1)
)

// RedisPool ...
type redisPool struct {
	pool *redis.Pool
}

// newRedisPool 创建redis连接池
func newRedisPool(server, password string) (*redisPool, error) {
	if server == "" {
		server = ":6379"
	}

	pool := &redis.Pool{
		MaxIdle:     3,
		IdleTimeout: 240 * time.Second,
		Dial: func() (redis.Conn, error) {
			c, err := redis.Dial("tcp", server)
			if err != nil {
				return nil, err
			}
			if password != "" {
				if _, err := c.Do("AUTH", password); err != nil {
					c.Close()
					return nil, err
				}
			}
			return c, err
		},
		TestOnBorrow: func(c redis.Conn, t time.Time) error {
			_, err := c.Do("PING")
			return err
		},
	}
	return &redisPool{pool}, nil
}

// InitQueue ...
func (r *redisPool) run() {
	conn := r.pool.Get()
	defer conn.Close()
	//往redis推
	go r.producer(ch)
	// 往redis取
	r.consumer()
}

// Producer 生产者,推给redis
func (r *redisPool) producer(ch <-chan *mysql.SecTaskInfo) {
	conn := r.pool.Get()
	defer conn.Close()
	for {
		select {
		case job := <-ch:
			b, _ := json.Marshal(job)
			_, err := conn.Do("rpush", "queue", b)
			if err != nil {
				fmt.Println("生产者发生错误, err:", err)
				return
			}
			fmt.Printf("[Enqueue(%v-%v)] succeed!\n", job.ID, job.TaskName)
		default:
			time.Sleep(time.Second)
		}
	}
}

// Consumer 消费者,从redis上取
func (r *redisPool) consumer() {
	conn := r.pool.Get()
	defer conn.Close()

	for {
		count, err := r.queuedJobCount()
		if err != nil {
			fmt.Println(err)
			return
		}
		if count == 0 {
			time.Sleep(time.Second)
			continue
		}
		reply, err := conn.Do("LPOP", "queue")
		if err != nil {
			fmt.Println(err)
			return
		}

		var j mysql.SecTaskInfo
		decoder := json.NewDecoder(bytes.NewReader(reply.([]byte)))
		if err := decoder.Decode(&j); err != nil {
			fmt.Println(err)
			return
		}
		// 执行nmap
		if j.OpenWeb == 1 {
			np := nmap.ReportNmap{TaskID: j.TaskMD5, PID: j.ID, Targets: j.TaskTargets}
			np.Nmapscan()
		}
		// 执行whatweb

		// 执行Poc
		if j.OpenPoc == 1 {
			poc := msploit.ReportPoc{TaskID: j.TaskMD5, PID: j.ID, Targets: j.TaskTargets, Protocol: j.Protocol}
			poc.PocScan()
		}
		// 执行漏洞利用

		Done <- true
		fmt.Printf("[outqueue(%v-%v)]\n", j.ID, j.TaskName)
	}
}

// QueuedJobCount 判断当前队列
func (r *redisPool) queuedJobCount() (int, error) {
	conn := r.pool.Get()
	defer conn.Close()

	lenqueue, err := conn.Do("llen", "queue")
	if err != nil {
		return 0, err
	}

	count, ok := lenqueue.(int64)
	if !ok {
		return 0, errors.New("类型转换错误")
	}
	return int(count), nil
}

// SendMsqChan 对往的任务推进管道
func SendMsqChan(job *mysql.SecTaskInfo) {
	ch <- job
}
