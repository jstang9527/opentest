package selenium

import (
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"time"

	"github.com/jstang9527/opentest/thirdpart/es"

	"github.com/jstang9527/opentest/conf"
	"github.com/jstang9527/opentest/model"
	mops "github.com/jstang9527/opentest/ops"
	"github.com/jstang9527/opentest/thirdpart/actionchain"
	"github.com/jstang9527/opentest/utils/dbdao"
	"github.com/jstang9527/opentest/utils/tools"
	"github.com/tebeka/selenium"
)

// TestTask 测试任务结构体
type TestTask struct {
	Project *model.Project     // 项目测试任务
	Wd      selenium.WebDriver // 驱动，每个域仅能独享
	Host    string             // 测试主机地址
}

// NewTestTask 实例化 测试任务结构体 ...
func NewTestTask(name, addr, host string, wd selenium.WebDriver) (testTask *TestTask, err error) {
	testTask = &TestTask{
		Wd:   wd,
		Host: host,
		Project: &model.Project{
			ProjectID:   tools.CreateMd5(name + addr + time.Now().Local().String()),
			ProjectName: name,
			ProjectAddr: addr,
			SnapshotIP:  host,
		},
	}
	//实例化就插入数据到数据库
	err = dbdao.InsertRowProject(testTask.Project)
	return
}

//阻塞函数, 直到错误或者加载完才返回。
func (t *TestTask) laodwait() error { //nil为加载完成
	for i := 0; i < 10; i++ {
		jsRt, err := t.Wd.ExecuteScript("return document.readyState", nil)
		if err != nil {
			return err
		}
		mops.Console("the %d attempt load page status: %v", i+1, jsRt)
		if jsRt == "complete" {
			mops.Console("网页加载完成")
			time.Sleep(time.Second)
			return nil
		}
		time.Sleep(time.Millisecond * 300) //三分之一秒
	}
	err := fmt.Errorf("Timeout waiting for web page to load more than 10 attempts")
	return err
}

// 执行行为链测试 ...
func (t *TestTask) executeActionChain(ActionChain *[]actionchain.ActionChain) { //传进去的是个复制品，但还是取地址降低内存
	//1.每个taskProject测试完记得关闭wd(web驱动客户端)
	defer func() {
		mops.Console("task_id:[%v], 退出测试程序, Byebye ~", t.Project.ProjectID)
	}()
	defer t.Wd.Quit()
	defer t.Wd.Close()

	//2.执行链行为
	for _, chain := range *ActionChain { //地址取值遍历,遍历行为链
		for _, action := range chain.ActionList { //遍历链中所有动作
			if err := t.actionDetial(&chain, &action); err != nil {
				break //只要有一步错了,切换下一条链
			}
			time.Sleep(time.Second * 3) //每一个小步骤等3秒
		}
		fmt.Println("-------循环完了，判断该此链的结果是否符合预期值-------------")
	}
}

//具体动作,每个动作的结果都要存在数据库中
func (t *TestTask) actionDetial(chain *actionchain.ActionChain, action *actionchain.Action) (err error) {
	start := time.Now()
	var status model.Level = model.Pass
	actionType := strings.TrimSpace(action.EleType) //去空格
	actionType = strings.ToLower(actionType)        //变小写
	var message string                              //接收数据
	//1.根据操作类型执行对应操作函数, 输入事件|点击事件|页面跳转事件|指标监控事件|数据抓取事件
	switch actionType {
	case "entry":
		err = t.EntryAction(action)
	case "input":
		err = t.InputAction(action)
	case "click":
		err = t.ClickAction(action)
	case "monitor":
		err = t.MonitorAction(action)
	case "parse":
		message, err = t.ParseAction(action)
	default:
		err = fmt.Errorf("params eleType not in [entry,input,click,monitor] in json file")
		status = model.Warning
	}
	//2.判断出错与否
	if err != nil { //有错
		if status == model.Pass { //非人为写错json
			status = model.Error
		}
	}
	//3.把正确或者错误的结果存起来
	if message != "" { //output输出
		message = fmt.Sprintf("%v, quota: %v, err: %v, output: %v.", action.ActionName, action.Value, err, message)
	} else {
		message = fmt.Sprintf("%v, quota: %v, err: %v", action.ActionName, action.Value, err)
	}
	screenshot := tools.CreateMd5(message) //截图名
	go t.createItem(chain.FuncName, message, screenshot, model.Level(chain.Priority), status, time.Now().Sub(start))
	return
}

// EntryAction 页面跳转
func (t *TestTask) EntryAction(action *actionchain.Action) (err error) { //不涉及修改Action对象，无需传地址
	url := "http://" + t.Project.SnapshotIP + action.ScopeURI
	//1.请求页面
	if err = t.Wd.Get(url); err != nil {
		err = fmt.Errorf("unable open page, url: [%v]", url)
		return
	}
	//2.判断加载是否完毕
	if err = t.laodwait(); err != nil {
		err = fmt.Errorf("failed wait load page, url: [%v]", url)
		return
	}
	return
}

// InputAction 输入事件
func (t *TestTask) InputAction(action *actionchain.Action) (err error) {
	var ele selenium.WebElement
	//1.先判断是id还是xpath
	if action.EleID != "" {
		ele, err = t.Wd.FindElement(selenium.ByID, action.EleID)
	} else {
		ele, err = t.Wd.FindElement(selenium.ByXPATH, action.EleXpath)
	}
	if err != nil {
		err = fmt.Errorf("element not found")
		return
	}
	return ele.SendKeys(action.Value)
}

// ClickAction 点击事件
func (t *TestTask) ClickAction(action *actionchain.Action) (err error) {
	var ele selenium.WebElement
	//1.先判断是id还是xpath
	if action.EleID != "" {
		ele, err = t.Wd.FindElement(selenium.ByID, action.EleID)
	} else {
		ele, err = t.Wd.FindElement(selenium.ByXPATH, action.EleXpath)
	}
	if err != nil {
		err = fmt.Errorf("element not found")
		return
	}
	return ele.Click()
}

// MonitorAction 监控某个指标是否在指定时间内达到预期值
func (t *TestTask) MonitorAction(action *actionchain.Action) (err error) {
	var ele selenium.WebElement
	var quota string
	start := time.Now()
	step := 1
	for i := 0; ; i++ {
		//1.先判断是id还是xpath
		if action.EleID != "" {
			ele, err = t.Wd.FindElement(selenium.ByID, action.EleID)
		} else {
			ele, err = t.Wd.FindElement(selenium.ByXPATH, action.EleXpath)
		}
		//2.查找元素
		if err != nil { //元素找不到
			//2.1 找不到视为正确
			if action.AllowErr {
				mops.Console("找不到就对了.............")
				return nil
			}
		} else { //元素找到
			//4.如果找到了, 就找对应元素文本
			quota, err = ele.Text()
			if err != nil {
				err = fmt.Errorf("unable get text of element")
				return
			}
			quota = strings.TrimSpace(quota)
			quota = strings.ToLower(quota)
			//4.是否满足指标
			if quota == action.Value {
				mops.Console("excpet: %v, output: %v", action.Value, quota)
				return nil
			}
			//不满足继续
		}

		//3.是否超过指定时间,超时找不到
		if time.Now().Sub(start) > time.Second*time.Duration(action.Duration) { //指标超时
			return fmt.Errorf("unable reach the quato [%v] in %d seconds", action.Value, action.Duration)
		}

		//5.超过10秒找不到就刷新页面
		if i%100 == 0 {
			t.Wd.Refresh()
			time.Sleep(time.Second * time.Duration(step))
			if step < 5 {
				step++
			}
		}
		time.Sleep(time.Millisecond * 100)
	}
}

// ParseAction 抓数据, 看用户的value,没设置的话空则info,有设置的话Warning
// 爬取最新一页数据
func (t *TestTask) ParseAction(action *actionchain.Action) (result string, err error) {
	var ele selenium.WebElement
	//1.先判断是id还是xpath
	if action.EleID != "" {
		ele, err = t.Wd.FindElement(selenium.ByID, action.EleID)
	} else {
		ele, err = t.Wd.FindElement(selenium.ByXPATH, action.EleXpath)
	}
	//2.抓数据
	rows, err := ele.FindElements(selenium.ByTagName, "tr")
	if err != nil {
		err = fmt.Errorf("element not found")
		return
	}
	for _, row := range rows {
		items, _ := row.FindElements(selenium.ByTagName, "td")
		for _, item := range items {
			text, _ := item.Text()
			result = fmt.Sprintf("%v, %v", result, strings.TrimSpace(text))
		}
		break //抓一个就好
	}
	return
}

// CreateItem 实例化功能项,保存截图,并插入到数据库、es
func (t *TestTask) createItem(name, message, screenshot string, priority, status model.Level, duration time.Duration) {
	testItem := model.Function{
		ProjectID:  t.Project.ProjectID,
		Name:       name,
		Message:    message,
		Screenshot: "/resources/screenshot/" + t.Project.ProjectID + "/" + screenshot + ".png", //web访问的路径,非内部路径
		Priority:   priority,
		Status:     status,
		Duration:   duration,
	}
	t.saveScreenshot(screenshot)
	dbdao.InsertRowDetail(&testItem)
	es.SendToESChan(t.Project, &testItem)
}

// 保存截图 ...(保存路径为服务器内文件路径, web访问路径非此路径)
func (t *TestTask) saveScreenshot(imgName string) {
	dirPath := conf.SCREENSHOT + "/" + t.Project.ProjectID + "/"
	if bl, _ := tools.PathExists(dirPath); !bl {
		os.Mkdir(dirPath, 0666)
	}
	imgName = dirPath + imgName + ".png"
	// time.Sleep(time.Second) //等1秒再截图
	if b, err := t.Wd.Screenshot(); err != nil {
		mops.Console("failed output screenshop by selenium, err: %v", err)
	} else {
		if err := ioutil.WriteFile(imgName, b, 0666); err != nil {
			mops.Console("cann't save screenshot in local, err: %v", err)
			return
		}
	}
}
