package selm2

import (
	"fmt"
	"regexp"
	"strings"
)

// Action ...
type Action struct {
	Info   string   //关键词
	Path   []string //关键词原始绝对路径
	First  []string //*[@id="root"]/div/ul/li/button/div/div ==> //*[id="root"]/div/ul/li/button
	Link   []string //*[@id="root"]/div/ul/li/a/div  ==>//*[id="root"]/div/ul/li/a
	Button []string //*[@id="root"]/div/ul/li/button/div/div ==> //*[id="root"]/div/ul/li/button
	Input  []string //*[@id="root"]/div/input
	Table  []string //*[@id="root"]/div/div/div[3]/div[2]/div[3]/div/div/div/div/div[1]/div/div/div/div/div/table/thead/tr/th[9]
	Node   []*H2j
	Index  []int //元素下标个数
}

// Reverse 数组倒序函数
func (a *Action) Reverse() *Action {
	arr := a.Node
	var length = len(arr)
	var temp H2j
	for i := 0; i < length/2; i++ {
		temp = *(arr)[i]
		*(arr)[i] = *(arr)[length-1-i]
		*(arr)[length-1-i] = temp
	}
	a.Node = arr
	// ---------------------------------
	indexArr := a.Index
	length = len(indexArr)
	var temp2 int
	for i := 0; i < length/2; i++ {
		temp2 = indexArr[i]
		indexArr[i] = indexArr[length-1-i]
		indexArr[length-1-i] = temp2
	}
	a.Index = indexArr
	return a
}

// Replace 解决特殊元素的转换,例如button
func (a *Action) Replace() *Action {
	for index, item := range a.Node {
		if name, ok := item.Attrs["type"]; ok { //特殊标签
			//如果匹配到button
			a.Path = append(a.Path, fmt.Sprintf("%v[%v]", name, a.Index[index]))
			// a.Link = a.Path[:index+1]
			continue
		}
		a.Path = append(a.Path, fmt.Sprintf("%v[%v]", item.Name, a.Index[index]))
	}
	return a
}

// Selector 利用Path初始化其他标签数组
func (a *Action) Selector() *Action {
	if len(a.Path) > 1 {
		a.First = a.Path[:len(a.Path)-1] //前一个标签，如果当前为li,那么前一个就是ul,就可以对其他li进行操作。比如批量删除
	} else {
		a.First = a.Path
	}

	for index, item := range a.Path {
		if is, _ := regexp.MatchString(`a\[\d+]$`, item); is { //a标签
			a.Link = a.Path[:index+1]
			continue
		}
		if is, _ := regexp.MatchString(`button`, item); is { //button标签
			a.Button = a.Path[:index+1]
			continue
		}
		if is, _ := regexp.MatchString(`input`, item); is { //input标签
			a.Input = a.Path[:index+1]
			continue
		}
		if is, _ := regexp.MatchString(`table`, item); is { //table标签
			a.Table = a.Path[:index+1]
			continue
		}
	}
	return a
}

// ToString 将数组转换成字符串
func (a *Action) ToString() *ActionDTO {
	prefix := `//*[@id="root"]/`
	// prefix := `//*[@id="app"]/`
	var link = ""
	var button = ""
	var input = ""
	var table = ""
	if len(a.Link) > 0 {
		link = fmt.Sprintf("%s%v", prefix, strings.Join(a.Link, "/"))
	}
	if len(a.Button) > 0 {
		button = fmt.Sprintf("%s%v", prefix, strings.Join(a.Button, "/"))
	}
	if len(a.Input) > 0 {
		input = fmt.Sprintf("%s%v", prefix, strings.Join(a.Input, "/"))
	}
	if len(a.Table) > 0 {
		table = fmt.Sprintf("%s%v", prefix, strings.Join(a.Table, "/"))
	}
	return &ActionDTO{
		Prefix: prefix,
		Info:   a.Info,
		Path:   fmt.Sprintf("%s%v", prefix, strings.Join(a.Path, "/")),
		First:  fmt.Sprintf("%s%v", prefix, strings.Join(a.First, "/")),
		Link:   link,
		Button: button,
		Input:  input,
		Table:  table,
	}
}

// *****************不在append路径，而是append对象，拿attr属性和name属性************************
// 分情况
// 点击类: 《全文检索》
//       a标签/button标签 -->找node.Text
//       input           -->找node.Attri["value"]

// 输入类: 《写死》
//       input           -->找node.Attri["title"]

// SearchText 检索文本XPath位置《只实现点击类》
func (a *Action) SearchText(nodes []*H2j) (ok bool) {
	temp := make(map[string]int, 10)
	for _, node := range nodes {
		// fmt.Println("->", node.Text)
		// 0.判断特殊标签
		if name, ok := node.Attrs["type"]; ok {
			temp[name]++
		} else {
			temp[node.Name]++
		}
		// 1.看看本节点的Text是否是target
		if strings.Contains(node.Text, a.Info) { //传统div、button点击按钮
			return true
		}
		// 1.看看本节点的title是否是target
		if text, ok := node.Attrs["title"]; ok { //input点击按钮
			if strings.Contains(text, a.Info) {
				return true
			}
		}
		// 2.不是的话,看本节点的孩子
		if node.Children != nil {
			c1 := node.Children
			if ok := a.SearchText(c1); ok {
				if name, ok := node.Attrs["type"]; ok {
					a.Index = append(a.Index, temp[name])
				} else {
					a.Index = append(a.Index, temp[node.Name])
				}
				a.Node = append(a.Node, node)
				return true
			}
		}
	}
	return false
}

// SearchTable 检索表格XPath位置  //*[@id="root"]/div/div/div[3]/div[2]/div/div[2]/div[1]/div/div/div/div/div/     -->自己补table
func (a *Action) SearchTable(nodes []*H2j) bool {
	temp := make(map[string]int, 10)
	for _, node := range nodes {
		// fmt.Println(node.Name)
		// 0.判断特殊标签
		if name, ok := node.Attrs["type"]; ok {
			temp[name]++
		} else {
			temp[node.Name]++
		}
		// 1.看看本节点是否是node.Name=table
		if strings.Contains(node.Name, "table") {
			return true
		}
		// 2.不是的话,看本节点的孩子
		if node.Children != nil {
			c1 := node.Children
			if ok := a.SearchTable(c1); ok {
				if name, ok := node.Attrs["type"]; ok {
					a.Index = append(a.Index, temp[name])
				} else {
					a.Index = append(a.Index, temp[node.Name])
				}
				a.Node = append(a.Node, node)
				return true
			}
		}
	}
	return false
}

///html/body/div[2]/div/div/div/div[2]/div/div/button[2]
///html/body/div[3]/div/div/div/div[2]/div/div/button[2]
///html/body/div[2]/div/div/div/div[2]/div/div/button[2]

///html/body/div[2]/div/div/div/div[2]/div/div/button[2]
///html/body/div[3]/div/div/div/div[2]/div/div/button[2]
///html/body/div[2]/div/div/div/div[2]/div/div/button[2]
